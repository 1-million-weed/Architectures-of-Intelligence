---
tags:
  - _Err_Design
  - Matthijs
  - Assignments
---


3.8.3 The Assignment Your task is to write a model for the subitizing task that always responds correctly by speaking the number of items on the display and also fits the human data well. The following are the results from my ACT-R model:113 ACT-R Tutorial 17-Oct-24 Unit Three CORRELATION: 0.980 MEAN DEVIATION: 0.230 Items Current Participant Original Experiment 1 0.54 (T ) 0.60 2 0.77 (T ) 0.65 3 1.00 (T ) 0.70 4 1.24 (T ) 0.86 5 1.48 (T ) 1.12 6 1.71 (T ) 1.50 7 1.95 (T ) 1.79 8 2.18 (T ) 2.13 9 2.41 (T ) 2.15 10 2.65 (T ) 2.58 You can see this does a fair job of reproducing the range of the data. However, the human data shows little effect of set size (approx. 0.05-0.10 seconds) in the range 1-4 and it shows a larger effect (approx. 0.3 seconds) above 4 in contrast to this model which increases about .23 seconds for each item. The small effect for little displays reflects the ability to perceive small numbers of objects as familiar patterns without needing to count them (which is called subitizing) and the larger effect for large displays probably reflects the time to retrieve counting facts. Both of those effects could be modeled, but would require significantly more productions and likely require mechanisms which have not been described to this point in the tutorial. Therefore the linear response pattern produced by this model is a sufficient approximation for our current purposes, and provides a fit to the data that you should aspire to match. There is a start to a model for this task found in the unit3 directory of the tutorial. It is named subitize- model.lisp and it is loaded automatically by the subitizing experiment code. The starting model defines chunks that encode numbers and their ordering from 0 to 10 similar to the count and addition models from unit 1 of the tutorial: (add-dm (zero isa number number zero next one vocal-rep "zero") (one isa number number one next two vocal-rep "one") (two isa number number two next three vocal-rep "two") (three isa number number three next four vocal-rep "three") (four isa number number four next five vocal-rep "four") (five isa number number five next six vocal-rep "five") (six isa number number six next seven vocal-rep "six") (seven isa number number seven next eight vocal-rep "seven") (eight isa number number eight next nine vocal-rep "eight") (nine isa number number nine next ten vocal-rep "nine") (ten isa number number ten next eleven vocal-rep "ten") (eleven isa number number eleven) (goal isa count step start) (start)) In addition to the number and next slots that were used for the numbers in unit 1, the number chunks also contain a slot called vocal-rep that holds the word string of the number which can be used by the model to speak it.114 ACT-R Tutorial 17-Oct-24 Unit Three The model also defines a chunk-type which can be used for maintaining control information in the goal buffer: (chunk-type count count step) It has a slot to maintain the current count and a slot to hold an indication of the current step. An initial chunk named goal which has a step slot value of start is also placed into the goal buffer in the starting model. As with the demonstration model for this unit, you may use only the goal buffer for holding the task information instead of splitting the representation between the goal and imaginal buffers to make it easier to focus on the visual portion of the modeling if you like. Also, as always, the provided chunk- types and chunks are only a recommended starting point and one is free to use other representations and control mechanisms if desired. There are two functions provided to run the experiment for the model in each implementation. The subitize-experiment function in the Lisp version and the experiment function in the subitize module of the Python version were described above and can be called without any parameters to perform one pass through all of the trials in a random order. Because there is no randomness in the timing of the experiment and we have not enabled any variability in the model’s actions, it is not necessary to run the model multiple times and average the results to assess the model’s performance (however there is randomness in where the items are displayed so if you choose to use a visual search strategy other than relying on the finsts you may want to test the model over several runs to make sure there are no problems with how it searches the display). The other function is called subitize-trial in the Lisp version and trial in the subitize module of the Python version. It can be used to run a single trial of the experiment. It takes one parameter, which is the number of items to display, and it will run the model through that single trial and return a list of the time of the response and whether or not the answer given was correct: ? (subitize-trial 3) (1.005 T) >>> subitize.trial(3) [1.005, True] As with the other models you have worked with so far, this model will be reset before each trial. Thus, you do not need to have the model detect the screen change to know when to transition to the next trial because it will always start the trial with the initial goal chunk. Also, like the sperling task, this experiment starts with the ACT-R trace enabled and runs by default with a real window and in real time. If you would like to make the task complete faster you can disable the trace as described above and change it to use a virtual window and not run in real time as described in the code description document for this unit. However, you will probably want to wait until you are fairly certain that it is performing the task correctly before doing so because having the trace and being able to watch the model do the task are very useful when developing and debugging the model.